\makeatletter\ifthesis@masterthesis
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Diskussion \& Zusammenfassung}
\label{sec:discussion}
\label{sec:conclusion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Die Komplexität moderner Softwaresysteme ist bereits sehr hoch und wird mit wachsender Rechenleistung und Konnektivität noch höher. Es braucht Strategien, um der steigenden Komplexität in der Qualitätssicherung gerecht zu werden. Das Feld der modellbasierten Testtechnologien ist vielfältig. Diese Arbeit zeigt, dass \Gls{MBT} automatische Tests weiter stärken kann, nicht nur um wiederkehrende und sich wiederholende Tätigkeiten zu testen. Auch die vollständige Exploration der Programmzweige und die damit verbundene Gewissheit ermöglicht \Gls{MBT} so einfach wie keine andere Testmethodik.\\
Im Kapitel \ref{sec:problemdescription} \Newnameref{sec:problemdescription} wurden \Gls{MBT} Werkzeuge für den Einsatz auf Ebene des Komponententests und des Integrationstests erprobt. Das Werkzeug \textit{ModelJUnit} ist in der Verwendung an die weit verbreiteten Komponententestwerkzeuge angelehnt. Modelle werden als Java-Klasse dargestellt und Zustandsübergänge werden auf Methodenebene annotiert. Das Werkzeug bietet keine grafische Notation und erzeugt auch keine visuelle Darstellung. Die Stärken von ModelJUnit liegen in der Einfachheit und in der guten Integrierbarkeit in bestehende Strukturen. Nachteilig wirkt sich aus, dass die Modelle weder die Verständlichkeit von grafischen Modellen, noch die Ausdrucksstärke von textuellen Notationen besitzt.\\
Auf Integrationstestebene gab es Bemühungen, den bekannten UML-Standard auszubauen und für die Definition von Testmodellen verwenden zu können. Das Ergebnis ist das UML Testing Profile. Dabei wurde die Sprache UML durch das Konzept der Profile erweitert und bietet nun Notationsmöglichkeiten speziell für das Testen. \Gls{UTP} bietet zwar einige essentielle Konzepte, die für den Gebrauch in komplexen Softwareprojekten nötig sind, aber wie die Generierung der Modelle erfolgen soll, bleibt den Werkzeugentwicklern vorbehalten. Eine Möglichkeit ist das manuelle Mapping von \Gls{UTP} Elementen zu JUnit, wie in Kapitel \ref{sec:utp} beschrieben. Dies gestaltet sich allerdings als recht aufwendig und bietet wenig zusätzlichen Nutzen, verglichen mit der direkten Erstellung der JUnit Testfälle ohne den Umweg über \Gls{UTP}.\\
Auch \textit{Graphwalker} lässt sich auf Integrationstestebene einsetzen. Es bietet einen Parser, der das Einlesen von Modellen in Form von Graphen ermöglicht. Graphwalker generiert daraus Java-Code, der mit Code für die Verbindung zum \Gls{SUT} gefüllt werden muss. Schlussendlich traviersiert Graphwalker das Modell auf die gewünschte Art und Weise. Das Werkzeug befähigt den Tester modellbasierte Tests gegen das \Gls{SUT} auszuführen, ohne auf gewohnte Mittel zur Verbindungsherstellung mit dem \Gls{SUT} verzichten zu müssen. Schnittstellentests könnten beispielsweise weiterhin mit \textit{SoapUI}, Oberflächentests mit \textit{Selenium} realisiert werden.\\
Die Fallstudie \ref{sec:fallstudie} hat gezeigt, dass modellbasierte Tests sinnvoll in agilen Softwareprojekten eingesetzt werden können, auch ohne damit andere Testmethodiken zu verdrängen. Sogar eine schrittweise Einführung in ein großes bestehendes Softwareprojekt ist möglich, vorausgesetzt es werden flexible Werkzeuge genutzt. Der Einsatz von Graphwalker hat sich als sehr unkompliziert herausgestellt, weil wenige tiefgreifende Eingriffe in die bestehende Teststrategie gemacht werden müssen. Das Werkzeug kann unabhängig von der gegebenen Umgebung genutzt werden. Es integriert sich, wenn gewünscht, auch in große Testmanagementprogramme von HP oder IBM. Dies ist durch die offene Java Schnittstelle möglich, die Graphwalker mitbringt. Außerdem ist es nicht nötig bestehenden Adapter-Code neu zu schreiben. Testfälle die als Java-Code vorliegen (z.B. Selenium) oder zumindest durch eine Java Schnittstelle ansprechbar sind (z.B. SoapUI) können in Graphwalker Tests eingebunden werden, weil Graphwalker selbst keine Annahme über das Ansprechen des \Gls{SUT} trifft.\\
%Schreiben wie die Kombination von BDD den Fachbereich einbindet und seine punktuellen Eigenschaften verliert
Das Resultatskapitel \ref{sec:results} hat eine Teststrategie vorgestellt, die auf die Schwächen bestehender Lösungen eingeht. Mittels der durchdachten Orchestrierung mehrerer Testansätze (gewöhnliche Komponententests, \Gls{BDT} und \Gls{MBT}) kann hocheffiziente Qualitätssicherung realisiert werden. Durch die Nutzung einer gemeinsamen Basis für Adapter-Code (der Testing-API, siehe Abschnitt \ref{sec:testing_api}) kann kurzfristig Wartungsaufwand minimiert werden und langfristig Zukunftssicherheit bei einem Werkzeugwechsel geboten werden. 
Abhängig vom fachlichen Kontext, können aufbauend darauf \Gls{BDT} und \Gls{MBT} Tests parallel zueinander eingesetzt werden. Beide Methodiken können dort verwendet werden, wo sie am besten passen, ohne damit den Wartungsaufwand zu erhöhen, weil sie auf einer gemeinsamen Schicht arbeiten.\\

Es hat sich außerdem gezeigt, dass eine Verschmelzung von \Gls{BDT} und \Gls{MBT} sinnvoll sein kann. Die Techniken haben strukturelle Ähnlichkeiten, wenn man betrachtet wie Tests definiert werden und welche Sicht sie auf das \Gls{SUT} einnehmen. \Gls{BDT} definiert mit seinen \textit{Given} und \textit{When} Teilen eine Aktion, die auf einem System in einem bestimmten Zustand ausgeführt wird. Der \textit{Then} Teil ist eine Aneinanderreihung von Überprüfungen, die zusammen evaluiert und über das Resultat des Testfalls entscheiden. Sieht man das \Gls{SUT} als abstrahierten endlichen Automaten und visualisiert man einen solchen \textit{Given-When-Then} Block, dann ist ein \Gls{BDT} Test ein Pfad von einem Knoten zu einem anderen. Sowohl die beiden Notationen, als auch die darunterliegenden Technologien haben ihre Stärken und Schwächen. Der \textit{Given} Teil ist eine kurze Zusammenfassung des Systemzustandes und kann als Modell genauer ausgedrückt werden. Wenn der Zustand aus dem Kontext klar ist, kann es aber genauso valide sein den knappen Einzeiler des \textit{Given} Teil zu verwenden und mit nur einem Knoten im Modell zu starten, der diesen repräsentiert. Der \textit{When} Teil kann fälschlicherweise suggerieren, dass eine Aktion eine atomare Handlung ist oder keine Alternativpfade zum Endzustand bestehen. In einem Modell kann durch mehrere Äste ausgeführt werden, auf welche Arten der Endzustand erreicht werden kann. Auf der Benutzeroberfläche wäre beispielsweise denkbar, dass eine Maske über einen Button, ein Kontextmenü oder ein Tastaturkürzel erreicht werden kann. Zuletzt steht der \textit{Then} Teil, der sich in einem Modell nicht von anderen Knoten unterscheidet. In der Realität finden dort aber die wichtigsten Überprüfungen statt. Diese verbergen sich im Code und sind auf grafischer Ebene nicht sichtbar. Viel ausdrücklicher ist hier \Gls{BDT}, indem die Erfolgsbedingungen klar ausformuliert werden. Eine Ebene über einzelnen Tests können auch \Gls{BDT}-Szenarien als Modell dargestellt werden und wiederum mit den ausdrucksstarken \textit{Then} Statements beendet werden.\\

Im Kapitel \ref{sec:mbt_bdt} wurde diese neuartige Teststrategie schließlich einer Evaluation unterzogen. Die Teststrategie wurde Erkenntnissen aus der Fallstudie gegenübergestellt. Es wurde gezeigt, dass sich mittels dem Einsatz der neuartigen Teststrategie die Schwachstellen in der Qualitätssicherung effektiv bekämpfen lassen: Die Spezifikationen an das Softwaresystem lassen sich verständlicher und gleichzeitig präziser darstellen, was die Kommunikation über Teamgrenzen hinweg erleichtert. Im Speziellen die Nicht-Technischen Domänenexperten, deren reibungslose Einbeziehung in den Entwicklungsprozess erfolgsentscheidend ist, können besser mitwirken. Weiters wurde die Teststrategie mit dem versuchten Einsatz von skriptbasierten GUI-Tests verglichen. Dabei hat sich gezeigt, dass sie entscheidende Vorteile gegenüber dem Einsatz von skriptbasierten GUI-Tests bietet. Dazu zählt die Entkopplung der Testlogik vom Softwaresystem und die Möglichkeit zur strukturierten Abdeckungskontrolle, die modellbasiertes Testen mit sich bringt.\\

Für die weitere Festigung dieses Themengebiets wären mehrjährige Fallstudien großer und lange andauernder Softwareprojekte höchst interessant. Durch den Vergleich von Qualitätsmetriken, aufgenommen während modellbasierte und nicht-modellbasierte Werkzeuge im Einsatz waren, ließen sich Schlüsse auf die tatsächliche Produktivitäts- und Qualitätssteigerung schließen die \Gls{MBT} verspricht.\\
Weiters bedarf es einer gewissen Standardisierung von Modellformaten und Werkzeugschnittstellen (siehe die Diskussion in Abschnitt \ref{sec:discussion_format}). Gegenwärtig werden Unternehmen eher abgeschreckt, Ressourcen in eine modellbasierte Strategie zu investieren für die keine entsprechende Standardisierung der Sprache vorliegt. Wenn die Weiterentwicklung eines kritischen Werkzeugs plötzlich eingestellt werden würde, könnten langjährige Bemühungen auf einen Schlag obsolet werden. Dieser Umstand kann durch die Möglichkeit Testartefakte mühelos wiederverwenden zu können gemildert werden. Das wiederum ist zur Zeit nicht möglich, da die vielen erhältlichen Werkzeuge grundlegend verschiedene Ansätze verfolgen.



























