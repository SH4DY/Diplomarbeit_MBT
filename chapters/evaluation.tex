%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluierung}
\label{sec:mbt_bdt}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Methode der Evaluierung}
Um die vorgestellte Teststrategie aus Abschnitt \label{sec:mbt_bdt_concept} zu evaluieren, wird sie anhand dreier Szenarien begutachtet: 

\begin{itemize}
\item \textbf{Strukturierte Gegenüberstellung der Eigenschaften der Teststrategie zu den proponierten Verbesserungsmaßnahmen:} Die von den Leitfadeninterviews abgeleiteten Verbesserungsmaßnahmen für die Entwicklung und Qualitätssicherung im Projekt, werden herangezogen um die Teststrategie an den Anforderungen eines realen Projekts zu messen. Hauptsächlich wird ersichtlich ob der Einsatz der Teststrategie den Verbesserungsmaßnahmen im Wege steht oder deren Durchführung erleichtert.
\item \textbf{Vergleichende Betrachtung und qualitative Bewertung der Teststrategie und skriptbasiertem Testen:} Rückblickend auf die Evaluation des Einsatzes von skriptbasierten Oberflächentests in der Fallstudie, wird bewertet wie es um die Eignung der Teststrategie für diesen Einsatzzweck bestellt ist.
\item \textbf{Qualitative Analyse und Vergleich mit verwandten Arbeiten:} Die Teststrategie wird anhand von Ansätzen und Konzepten aus der Literatur analysiert und mit ähnlichen Arbeiten verglichen. 
\end{itemize}

\section{Gegenüberstellung zu Verbesserungsmaßnahmen}
Es folgt die Gegenüberstellung der Eigenschaften der Teststrategie zu den drei vorgeschlagenen Verbesserungsmaßnahmen (\ref{sec:massnahmen}):

\subsubsection{Form der Spezifikationen}
In den Interviews mit Mitgliedern des Fachbereichs hat sich gezeigt, dass Spezifikationen uneinheitlich verfasst werden. \Gls{COS} werden zwar eingesetzt, es gibt aber keine Regeln in welchem Detailgrad diese vorliegen müssen. Außerdem, und dies ist eine allgemeine Schwierigkeit im Einsatz von isolierten \Gls{BDT}'s, variiert die Empfindung darüber wieviele \Gls{BDD}-Spezifikationen ausreichend sind.\\ Der Einsatz der vorgestellten Testarchitektur verbessert diesen Prozess an mehreren Stellen:

\begin{itemize}
\item \textbf{Anzahl der \Gls{BDT}'s:} Wenn \Gls{BDT}'s  an modellbasierte Tests gebunden sind, lässt sich einfacher abschätzen wieviele \Gls{BDD}-Spezifikationen nötig sind, um einen ausreichend präzisen Test für ein gegebenes Teilsystem zu erstellen. Dies geht aus persönlicher Erfahrung mit dem Umgang von \Gls{MBT} hervor.
\item \textbf{Versionierung und Historisierung:} Eine Versionierung von Anforderungen ist auch mit dem isolierten Einsatz von \Gls{BDT} möglich. Durch die Menge an Spezifikationen und die noch größere Menge an zugehörigen \Gls{BDT}'s, die ein modernes Softwareprojekt aufweist, wird es schwer festzustellen, welche \Gls{BDT}'s überhaupt noch gültig sind. Hingegen lässt sich bei \Gls{BDT}'s, die an automatisierte modellbasierte Tests gekoppelt sind, sehr schnell feststellen, ob diese noch gültig sind. Die automatisierten Tests schlagen fehl.
\item \textbf{Format:} Bei Einigung auf den Einsatz der vorgestellten Testarchitektur wäre eine einheitliche Form der Spezifikationen gegeben.
\end{itemize}

\subsubsection{Kommunikation über Teamgrenzen}
Mehrere Teams, die an einem Softwareprojekt mitwirken, sind bereits schwer zu koordinieren und erfordern eine reibungslose Kommunikationsstruktur. Wenn manche Gruppierungen nur über beschränkte Zeiträume am Projekt teilnehmen, ist es noch schwieriger diese produktiv miteinzubeziehen ohne Gefahr zu laufen den Projektfortschritt zu verlangsamen. Vor allem aus den Interviews mit Projektmitgliedern, die nicht an der täglichen Entwicklung teilnehmen, stellte sich dies heraus. Die vorgestellte Teststrategie ist kein Kommunikationskanal oder ähnliches, ermöglicht aber den Informationsaustausch bezüglich der Software über Prosatext hinaus. Weil die Modelle das Softwaresystem nicht nur veranschaulichen oder nachstellen sondern tatsächlich prüfen und damit repräsentieren, können sie dazu verwendet werden um über Teamgrenzen hinweg zu kommunizieren. Ihre grafische Einfachheit machen sie weitflächig verständlich aber weniger mehrdeutig als Prosatext. Um diese Art der Kommunikation weiter zu präzisieren, können die Modelle mit \Gls{BDT} Elementen angereichert werden, wie es in Abschnitt \ref{sec:mbt_bdt_parallelen} gezeigt wurde. Auch dieser Schritt ist nicht an technische Fähigkeiten gekoppelt. Es handelt sich um einfache Aussagen im Kontext von \textit{Given-When-Then}. Damit kann das Programm auf beliebigen Ebenen in frei wählbarem Detailgrad dargestellt werden. Auch die Vergleichbarkeit zweier Aussagen erhöht sich massiv gegenüber der Aussage von Prosatext. Einzige Voraussetzung um sich mittels Modellen und BDT zu verständigen ist ein flächendeckendes Grundverständnis für beide Methodiken. In der Fallstudie hat sich gezeigt, dass dies in einem Zeitrahmen von einem halben Arbeitstag erreichbar ist.

\subsubsection{Einbeziehen des Fachbereichs}
In Prozessmodellen wie dem V-Modell und dessen Verwandten \cite{hohn_v-modell_2008} werden Anforderungen an das Softwaresystem vom Fachbereich gesammelt und in strukturierter Form an das Entwicklungsteam weitergeleitet. Naturgemäß werden Tests auf Komponenten- und Integrationsebene gänzlich vom Entwicklungsteam entworfen. Nur sie haben den nötigen Einblick in die Architektur des Systems. Infolgedessen hat sich in der Fallstudie ergeben, dass weitreichendere Integrations- und Systemtests nur vom Fachbereich durchgeführt wurden. In keine der beiden Richtungen wurde klar kommuniziert welchen Fokus die durchgeführten Tests hatten und welche Bereiche damit abgedeckt wurden. Durch das Einbeziehen des Fachbereichs bei der Konkretisierung der Anforderungen auf Seiten der Entwickler besteht großes Einsparungspotenzial. Zeit- und Ressourcenersparnis zeigt sich an zwei Stellen: Erstens ermöglichen Modelle und \Gls{BDT}'s vor der eigentlichen Entwicklung bereits eine Erhöhung der Spezifikationspräzision. Zweitens stellen diese gleichzeitig eine Testdefintion dar. Zum Zeitpunkt der System- und Abnahmetests liegen also bereits automatisierte oder zumindest einfach automatisierbare Tests vor. All dies wird ermöglicht indem die Arbeit zwischen Entwicklung und Fachbereichen enger aufeinander abgestimmt wird. Als Werkzeug dient die Kombination von \Gls{MBT} und \Gls{BDT}.

\section{Vergleich mit skriptgesteuerten GUI-Tests}
Skriptgesteuerte Tests der Benutzeroberfläche finden breite Anwendung in Softwareprojekten \cite{graham_experiences_2012}. Auch in der Fallstudie wurde die Einführung von skriptgesteuerten Tests evaluiert. Abschnitt \ref{sec:versuch_script} erläutert die Gründe, weshalb von einer solchen Teststrategie wieder abgesehen wurde.\\
Auch die vorgestellte Teststrategie lässt sich auf Ebene der Benutzeroberfläche einsetzen. Die Rahmenbedingungen für den Einsatz sind somit vergleichbar. Im praktischen Einsatz unterscheiden sie sich aber gravierend:

\begin{itemize}
\item \textbf{Entkopplung und Stabilität durch Testing API}  Skriptgesteuerte Tests werden unmittelbar gegen das \Gls{SUT} geschrieben. Es befindet sich also keine Abstraktionsschicht zwischen den Skripts, die Benutzereingaben machen, und dem zu testenden System. Dies macht Testfälle sehr anfällig gegenüber Änderungen in der Benutzeroberfläche. Einfache kosmetische Änderungen in der Benutzeroberfläche lassen sich durch Modularisierungsbausteine, wie sie einige Werkzeuge anbieten, abfangen. Wenn die Benutzeroberfläche aber groben strukturellen Änderungen ausgesetzt wird, muss ein skriptgesteuerter Testfall in der Regel verworfen werden. Im Gegensatz dazu bildet die vorgeschlagene Testing API eine Entkopplungsschicht zwischen der Beschreibung eines Testfalls und der tatsächlichen Implementierung. Diese Technologie ließe sich auch in Isolation mit herkömmlichen skriptgesteuerten Tests verwenden. Ihre volle Stärke kann die Testing API aber vor allem mit einer naturgemäß modularen Testmethodik ausspielen. Bei \Gls{MBT}, als gerichteten Graphen betrachtet, ist dies der Fall. Jeder Knoten oder Teilgraph kann einzeln betrachtet und sogar ausgeführt werden. Teilgraphen können als Knoten gesehen werden und Knoten können zu Teilgraphen expandiert werden. Die Testing API kann im Detailgrad der angebotenen Funktionalität ebenso variieren. Der Wartungsaufwand bei Änderungen in der Benutzeroberfläche beschränkt sich auf das Ändern von Funktionen in der Testing API. Modelle, die jene Funktionalität verwenden, müssen nicht angepasst werden. Bei groben strukturellen Änderungen, ändern sich nicht mehrere Testfälle sondern ein einzelnes Modell, welches diesen Bereich des \Gls{SUT} abdeckt und möglicherweise in vielen anderen Modellen verschachtelt ist (Abschnitt \ref{sec:graphwalker_modularisierung} zeigt wie mit dem Werkzeug Graphwalker eine solche Verschachtelung von Modellen möglich ist).
\item \textbf{Abdeckungskontrolle durch Modellbasierung} Skriptgesteuerte Testfälle können einen oder mehrere Pfade durch das \Gls{SUT} beschreiten. Außerdem können Endzustände in fast beliebiger Form überprüft werden. Skripts bieten aber keine grafische Darstellung oder sonstige Möglichkeit, um schnell festzustellen welchen Teil des \Gls{SUT} sie abdecken. Eine hohe Anzahl von skriptbasierten Testfällen ist nötig, um eine `gefühlsmäßig' hohe Abdeckung zu erreichen. Es ist schwierig eine Aussage zu treffen, wie hoch die tatsächliche Abdeckung ist. Im Gegensatz dazu wird das \Gls{SUT} beim modellbasierten Test zu Teilen oder als Ganzes modelliert. Durch die Automatisierung dieser Modelle kann einfach eine Aussage darüber getroffen werden wie hoch die Testabdeckung auf der jeweiligen Teststufe tatsächlich ist \cite{utting_practical_2007}. Da die vorgestellte Teststrategie vollständig auf \Gls{MBT} basiert, gilt dies auch für diese. 
\item \textbf{Entwicklung und Wartung durch Nicht-Technische Projektmitglieder} Skriptgesteuerte Tests liegen in Form von Skripts vor. Einige Werkzeuge bieten Funktionalitäten, um Testfälle ohne Programmierkenntnisse zu erstellen. In der Fallstudie hat sich gezeigt, dass diese halbautomatisch generierten Skripts für den realen Einsatz über einen längeren Zeitraum kaum zu gebrauchen sind. Die generierten Skripts sind schwer les- und wartbar. Weiters verwenden sie keine, von den Testentwicklern vorgefertigten, Modularisierungsbausteine. Im Praxiseinsatz ergeben sich nun zwei Optionen: Entweder müssen solche, von nicht-technischem Personal erstellten, Testfälle von Entwicklern stark überarbeitet werden. Oder nicht-technisches Personal wird in keinster Form für die Erstellung von automatisierten Tests eingesetzt. Erstere Option erhöht den Ressourcenaufwand für jeden Testfall. In der Fallstudie hat sich gezeigt, dass sich pro Testfall der Zeitaufwand ungefähr verdoppelt. Zweitere Option ist aber qualitätstechnisch ebenso kritisch, weil Tests auf der Benutzeroberfläche den Charakter eines Abnahmetests haben. Gerade die Fachbereiche würden also viel Nutzen aus diesen ziehen, können sich aber nur schwer daran beteiligen.\\
Demgegenüber können nicht-technische Projektmitglieder bedeutend mehr an Testfällen mitwirken, die mit der vorgestellten Teststrategie erstellt werden. Modelle haben eine grafische Notation, die kaum Einschulung benötigt. \Gls{BDT}'s ähneln den weitverbreiteten \Gls{COS} sehr und stellen deshalb auch keine Schwierigkeit dar. Wenn die Testing API als offener Katalog geführt und publiziert wird, kann nicht-technisches Personal sogar Adapter-Code und Überprüfungen einfügen. Entwickler oder dedizierte Testfallentwickler müssen höchstwahrscheinlich trotzdem in den Automatisierungsprozess miteinbezogen werden. Ihre Beteiligung ist aber geringer, da der gesamte Vorgang viel transparenter ist.
\end{itemize}

Angesichts dieser Punkte und bezogen auf Ressourcenverwendung sowie Softwarequalität, ist die vorgestellte Testarchitektur effizienter als skriptgesteuerte GUI-Tests.

\section{Qualitative Analyse und Vergleich mit verwandten Arbeiten}

Im Laufe der Recherche für diese Arbeit hat sich gezeigt, dass modellbasiertes Testen ein sehr umfangreiches Thema ist. Es finden sich Arbeiten, Fallstudien und Anwendungsbeispiele in der Industrie, die zwar alle von modellbasiertem Testen sprechen, aber sich trotzdem gravierend unterscheiden. Deshalb ist ein differenzierter Vergleich notwendig. Diese Tatsache unterstreicht gleichzeitig die Wichtigkeit modellbasierte Testmaßnahmen auf die Struktur des Projekts und die Art der zu testenden Software maßzuschneidern. Weiters kann \Gls{MBT} in allen bekannten Teststufen (siehe Abschnitt \ref{sec:teststufen} für eine Beschreibung der Stufen in der Domäne des Softwaretests) eingesetzt werden und abhängig von der Höhe der bestehenden Testqualität macht es Sinn \Gls{MBT} nur punktuell einzusetzen. Mit dem in dieser Arbeit vorgeschlagenen Konzept ist dies, im Gegensatz zu gesamtheitlichen Lösungsansätzen für \Gls{MBT}, ohne weiteres möglich.\\
Viele Arbeiten wie \cite{pretschner_one_2005} \cite{pinheiro_model-based_2013} \cite{sensler_testautomatisierung_2011} präsentieren Konzepte und stellen die verwendeten Werkzeuge und das technische Vorgehen in den Mittelpunkt. Die menschliche Komponente wird dabei nicht erwähnt. In der Fallstudie dieser Arbeit hat sich gezeigt, dass es nicht reicht ein generisches aber technisch ausgereiftes Konzept einzuführen. In umfangreichen Softwareprojekten sind sehr viele Akteure mit den verschiedensten technischen und fachlichen Hintergründen beteiligt. Wenn die Teststrategie nicht diesen Umständen angepasst wird, leidet die Qualität des gesamten Projekts darunter. Ziel einer Teststrategie sollte sein, das Softwaretesten für so viele involvierte Parteien wie möglich verständlich zu machen. Im Sinne des gemeinsamen Vokabulars (die Grundprinzipien von \Gls{BDD} werden in Abschnitt \ref{sec:bdd} erklärt) ist es nur von Vorteil, wenn zwischen fachlichem und technischem Testen volle Transparenz herrscht. Weiters ist die Beteiligung der Akteure, die die zu entwickelnde Software spezifizieren, wünschenswert. Das Entwerfen von Software wird \textit{bewusster} und gleichzeitig präziser. Der zeitliche Aufwand für die Spezifikation erhöht sich möglicherweise, es wurde in der Vergangenheit mehrfach bewiesen, dass Ungenauigkeiten in der Spezifikation massive Auswirkungen auf das Endprodukt haben. Die Kosten zur Beseitigung erhöhen sich drastisch sich mit dem Fortschritt des Projekts. Deshalb wirkt sich der erhöhte Zeitaufwand für die Modellierung und Kommunikation in den frühen Stadien des Projekts positiv auf das Endergebnis aus.\\
Einige Werkzeuge, unter anderem auch das in den Experimenten von IBM \cite{farchi_using_2002} verwendete, setzen voraus, dass in den Modellen gewisse Abdeckungskriterien definiert werden müssen. Meist sind dies Werkzeuge, die textuelle Modellierungssprachen verwenden. Diese haben den Vorteil, dass sehr präzise Vor- und Nachbedingungen (Pre- und Postconditions) definiert werden können. Verglichen mit der Kombination von Graphwalker (siehe Abschnitt \ref{sec:graphwalker}), mit grafischer Notation, und BDD-Tests sind diese weniger flexibel. Die Notation von Graphwalker ist so simpel gehalten, dass keinerlei Aussagen über Abdeckungs- oder Abbruchkriterien gemacht werden können. Das Modell und dessen Adapter-Code wird offline generiert (siehe Abschnitt \Newnameref{sec:online_offline} \ref{sec:online_offline}). Modell und Adapter-Code können nun integriert oder von beliebiger Stelle aus gestartet werden. Das Modell und dessen Traversierung wird vollkommen entkoppelt. Das Modell muss also nicht dupliziert und modifiziert werden, um verschiedene Traversierungen zu generieren.\\
Grafische Notationen haben weiters den Vorteil, dass sie durch die Visualisierung leichter verständlich sind. Gleichzeitig besteht die Gefahr, dass Details übersehen werden oder gar nicht präzise genug notiert werden können. Das vorgestellte Konzept geht diesen Missstand auf zwei Arten an. Einerseits bietet das gewählte Werkzeuge eine sehr schlanke Syntax, die es nicht zulässt, dass wichtige Details unsichtbar modelliert werden können. Die grafische Syntax behindert den Testentwickler aber auch nicht, indem nur ein Subset von Fähigkeiten in der grafischen Syntax verfügbar gemacht werden. Andererseits, wird einfach auf BDD-Tests zurückgegeriffen wenn sehr spezifische Ein- und Ausgabe Kombinationen auf einem gewissen Zustand geprüft werden sollen. Wie in Abschnitt \ref{sec:mbt_bdt} erklärt, kann durch die Vereinigung von \Gls{BDT} und \Gls{MBT} auf die Expressivität von \Gls{BDT} \textit{Then} Klauseln zurückgegriffen werden, wenn dies am nötigsten ist: In Knoten in denen Überprüfungen stattfinden, die in der grafischen Notation nicht ersichtlich sind.\\
Ein anderer Gesichtspunkt ist die Einfachheit der Einführung der Teststrategie. Generische Plattformen, wie die von \citeauthor{zech_generic_2012} vorgeschlagene \cite{zech_generic_2012}, konzentrieren sich nicht nur auf die Modellierung und Traversierung des \Gls{SUT}. Vielmehr wollen sie eine gesamtheitliche Basis für das Testen schaffen. In großen Langzeitsoftwareprojekten ist eine solche Einführung aber extrem schwierig und in der Praxis selten. Die vorgeschlagene Teststrategie dieser Arbeit lässt eine inkrementelle und, zu agilen Projekten passende, iterative Einführung zu. Ebenso kann der modellbasierte Teil des Konzepts auf eigenständige Module des \Gls{SUT}'s beschränkt werden. Der BDD-Teil des Konzept kann zwar auch iterativ eingeführt werden, aber eine Beschränkung auf Teile des Projekts würde keinen Sinn machen. Dies hätte zur Folge, dass die Spezifikationen in Form von \Gls{COS} mittels zwei verschiedener System festgehalten oder versioniert werden müssten. Mittel- bis langfristig entstünden Überschneidungen und Unklarheiten, welche \Gls{COS} denn nun gültig sind und bei welchen es nötig ist, sie in das Regressionstesten einfließen zu lassen.\\
Eine ähnliche Kombination von \Gls{MBT} und \Gls{BDT} schlägt auch \citeauthor{binder_model-based_2014} vor \cite{binder_model-based_2014}. Diesen Ansatz, den er in einer Präsentation \cite{binder_model-based_2014} erklärte aber in keiner schriftlichen Publikation detaillierte, scheint eine sehr ähnliche Idee zu verfolgen. Auch er hebt heraus wie sich \Gls{MBT} und \Gls{BDT} ergänzen und in die agile Vorgehensweise passen. Er warnt aber davor, dass \Gls{BDT} nur einen kleinen Teil des \textit{happy-path} abdecken. Soll heißen, dass das System mittels \Gls{COS} nur auf sehr wenigen Pfaden getestet wird. Außerdem wächst die Anzahl der zu wartenden \Gls{BDD}-Spezifikationen mit der Größe der Code-Basis. Meist hat dies zur Folge, dass ältere Spezifikationen in Vergessenheit geraten und nicht mehr in die Regressionstests miteinbezogen werden. Um zweiterem Nachteil entgegenzuwirken müssen \Gls{BDD}-Spezifikationen sehr sorgfältig und mit Hinblick auf die Programmlogik entworfen werden. Außerdem muss die Versionierung Teamübergreifend nahtlos funktionieren. Der Gedanke der gemeinsamen Verwendung von \Gls{BDT} und \Gls{MBT} wurde in dieser Arbeit weitergeführt. Daraus entstanden ist nicht nur die Empfehlung zur parallelen Verwendung beider Techniken, sondern auch eine Anleitung zur Vereinigung und Nutzung der jeweiligen Stärken. \\
Gerade für die agile Entwicklung ist die Kombination von \Gls{BDT} und \Gls{MBT} wie maßgeschneidert: Agile Entwicklung bedeutet unter anderem viel Kontakt mit dem Kunden und damit auch die Notwendigkeit der Auseinandersetzung mit Spezifikationsänderungen und Feedback. \Gls{COS}-artige Definitionen kommen in vielen Softwareprojekten bereits zum Einsatz und sind daher, sowohl dem fachlichen, als auch dem technischen Personal bekannt. Der Schritt von \Gls{COS}-Tabellen zu Behavior Driven Testfällen, egal welches Framework dazu benutzt wird, ist unkompliziert. Wenn der Einsatz von \Gls{BDT} sorgfältig und gut koordiniert umgesetzt wird, ist die damit einhergehende Versionierung der \Gls{COS} ein wertvoller Nebeneffekt, der die Organisation des Softwareprojekts vereinfacht. Aus Kundensicht sind \Gls{COS} oft notwendig, da sie kurz und bündig vertragliche Abkommen darstellen. Auch wenn der Kunde beim Abnahmetest auf \Gls{COS} Spezifikationen besteht, muss das System durch breitere Maßnahmen regressiv getestet werden. Hier ergänzen modellbasierte Tests die Qualitätssicherungsmaßnahmen. Eine \Gls{COS} kann als einzelner Pfad in einem Modell gesehen werden. Der modellbasierte Test prüft dann, mit variablem Grad an Prüflogik, alle anderen Pfade. Diese Vorgehensweise schafft eine weitere Schicht an Sicherheit und lässt sich gut in bestehende Projekt- und Softwarestrukturen integrieren. Durch die Nutzung einer durchdachten Testing API (wie in Abschnitt \ref{sec:testing_api} beschrieben) können Wartungsaufwände minimiert werden, indem nur eine Codebasis für Adapter-Code besteht. Die Testing API stellt außerdem eine zukunftssichere Barriere vor Änderungen auf Seiten des Testwerkzeuges dar. Dieses kann ausgetauscht werden ohne die Aufwände für die Anbindung des \Gls{SUT} zunichte zu machen.\\
Die in Abschnitt \ref{sec:mbt_bdt_concept} vorgeschlagene kombinierte Verwendung von \Gls{BDT} und \Gls{MBT} lässt das Projekt von den Stärken beider Ansätze profitieren. \Gls{BDT} und \Gls{MBT} lassen sich flexibel miteinander verschmelzen und sowohl den technischen, als auch den organisatorisch geschäftlichen Prozessen anpassen. Das \Gls{SUT} kann damit systematischer und flächendeckender getestet werden, ohne signifankte Mehraufwände in Kauf nehmen zu müssen.