%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Evaluierung}
\label{sec:mbt_bdt}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\todo[color=yellow]{@Boris: Neu}
\section{Methode der Evaluierung}
Um die vorgestellte Teststrategie aus Abschnitt \label{sec:mbt_bdt_concept} zu evaluieren werden die aus den Leitfadeninterviews gewonnenen Schwachstellen (siehe \ref{sec:schwachstellen_raiffeisen}) herangezogen. Damit können die Eigenschaften der Teststrategie an einem realen Projekt gemessen werden. Hauptsächlich wird ersichtlich ob der Einsatz der Teststrategie den Verbesserungsmaßnahmen im Wege steht oder deren Durchführung erleichtert.\\
Zweitens wird die Teststrategie mit dem Einsatz von herkömmlichen skriptgesteuerten Tests verglichen. Auch in der Fallstudie wurde ein Versuch unternommen solche Tests einzuführen. Es soll gezeigt werden, ob die Teststrategie kritische Attribute besitzt, die den Einsatz erfolgreicher machen würden.\\
Zuletzt werden mehrere Zugewinne angeführt, die durch den Einsatz der Teststrategie erlangt werden.

\section{Gegenüberstellung mit Verbesserungsmaßnahmen}
Es folgt die Gegenüberstellung der Eigenschaften der Teststrategie zu den drei vorgeschlagenen Verbesserungsmaßnahmen (\ref{sec:massnahmen}:

\subsubsection{Kommunikation über Teamgrenzen}
Mehrere Teams die an einem Softwareprojekt mitwirken sind bereits schwer zu koordinieren und erfordern eine reibungslose Kommunikationsstruktur. Wenn manche Gruppierungen nur über beschränkte Zeiträume am Projekt teilnehmen, ist es noch schwieriger diese produktiv miteinzubeziehen ohne Gefahr zu laufen den Projektfortschritt zu verlangsamen. Vor allem aus den Interviews mit Projektmitgliedern, die nicht an der täglichen Entwicklung teilnehmen, stellte sich dies heraus. Die vorgestellte Teststrategie ist kein Kommunikationskanal oder ähnliches, ermöglicht aber den Informationsaustausch bezüglich der Software über Prosatext hinaus. Weil die Modelle das Softwaresystem nicht nur veranschaulichen oder nachstellen sondern tatsächlich prüfen und damit repräsentieren, können sie dazu verwendet werden um über Teamgrenzen hinweg zu kommunizieren. Ihre grafische Einfachheit machen sie weitflächig verständlich aber weniger mehrdeutig als Prosatext. Um diese Art der Kommunikation weiter zu präzisieren, können die Modelle mit \Gls{BDT} Elementen angereichert werden, wie es in Abschnitt \ref{sec:mbdt_bdt_parallelen} gezeigt wurde. Auch dieser Schritt ist nicht an technische Fähigkeiten gekoppelt. Es handelt sich um einfache Aussagen im Kontext von \textit{Given-When-Then}. Damit kann das Programm auf beliebigen Ebenen in frei wählbarem Detailgrad dargestellt werden. Auch die Vergleichbarkeit zweier Aussagen erhöht sich massiv gegenüber Prosatext. Einzige Voraussetzung um sich mittels Modellen und BDT zu verständigen ist ein flächendeckendes Grundverständnis für beide Methodiken. In der Fallstudie hat sich gezeigt, dass dies in einem Zeitrahmen von einem halben Arbeitstag erreichbar ist.

\subsubsection{Einbeziehen des Fachbereichs}
Üblicherweise werden Anforderungen an das Softwaresystem vom Fachbereich gesammelt und in strukturierter Form an das Entwicklungsteam weitergeleitet. Naturgemäß werden Tests auf Komponenten- und Integrationsebene gänzlich vom Entwicklungsteam entworfen. Nur sie haben den nötigen Einblick in die Architektur des Systems. Infolgedessen hat sich in der Fallstudie ergeben, dass weitreichendere Integrations- und Systemtests nur vom Fachbereich durchgeführt wurden. In keine der beiden Richtungen wurde klar kommuniziert welchen Fokus die durchgeführten Tests hatten und welche Bereiche damit abgedeckt wurden. Durch das Einbeziehen des Fachbereichs bei der Konkretisierung der Anforderungen auf Seiten der Entwickler besteht großes Einsparungspotenzial. Zeit- und Ressourcenersparnis zeigt sich an zwei Stellen: Erstens ermöglichen Modelle und \Gls{BDT}'s vor der eigentlichen Entwicklung bereits eine Erhöhung der Spezifikationspräzision. Zweitens stellen diese gleichzeitig eine Testdefintion dar. Zum Zeitpunkt der System- und Abnahmetests liegen also bereits automatisierte oder zumindest einfach automatisierbare Tests vor. All dies wird ermöglicht indem die Arbeit zwischen Entwicklung und Fachbereichen enger aufeinander abgestimmt wird. Als Werkzeug dient die Kombination von \Gls{MBT} und \Gls{BDT}.

\subsubsection{Form der Spezifikationen}
In den Interviews mit Mitgliedern des Fachbereichs hat sich gezeigt, dass Spezifikationen uneinheitlich verfasst werden. \Gls{COS} werden zwar eingesetzt, es gibt aber keine Regeln in welchem Detailgrad diese vorliegen müssen. Außerdem, und dies ist eine allgemeine Schwierigkeit im Einsatz von isolierten \Gls{BDT}'s, variiert die Empfindung darüber wieviele \Gls{BDD}-Spezifikationen ausreichend sind.\\ Der Einsatz der vorgestellten Testarchitektur würde diesen Prozess an mehreren Stellen verbessern:

\begin{itemize}
\item \textbf{Anzahl der \Gls{BDT}'s:} Wenn \Gls{BDT}'s  an modellbasierte Tests gebunden sind, lässt sich einfacher abschätzen wieviele \Gls{BDD}-Spezifikationen nötig sind, um einen ausreichend präzisen Test für ein gegebenes Teilsystem zu erstellen. Dies geht aus persönlicher Erfahrung mit dem Umgang von \Gls{MBT} hervor.
\item \textbf{Versionierung und Historisierung:} Eine Versionierung von Anforderungen ist auch mit dem isolierten Einsatz von \Gls{BDT} möglich. Durch die schiere Menge an Spezifikationen und die noch größere Menge an zugehörigen \Gls{BDT}'s, die ein modernes Softwareprojekt aufweist, wird es schwer festzustellen welche \Gls{BDT}'s überhaupt noch gültig sind. Hingegen lässt sich bei \Gls{BDT}'s, die an automatisierte modellbasierte Tests gekoppelt sind, sehr schnell feststellen, ob diese noch gültig sind. Die automatisierten Tests würden fehlschlagen.
\item \textbf{Format:} Bei Einigung auf den Einsatz der vorgestellten Testarchitektur wäre eine einheitliche Form der Spezifikationen gegeben.
\end{itemize


\section{VERSUS Skriptgesteuerte GUI Tests}
%Entkopplung durch TestingAPI
%Stabilität durch TestingAPI
%Erstellung nur durch Entwickler
%Wartung nur durch Entwickler

\section{Weitere Zugewinne durch die vorgestellte Teststrategie}
Gerade für die agile Entwicklung ist die Kombination von BDD und \Gls{MBT} wie maßgeschneidert. Agile Entwicklung bedeutet, unter anderem, viel Kontakt mit dem Kunden und damit auch die Notwendigkeit der Auseinandersetzung mit Spezifikationsänderungen und Feedback. \Gls{COS}-artige Definitionen kommen in vielen Softwareprojekten bereits zum Einsatz und sind daher sowohl dem fachlichen als auch dem technischen Personal bekannt. Der Schritt von \Gls{COS}-Tabellen zu Behavior Driven Testfällen, egal welches Framework dazu benutzt wird, ist unkompliziert. Wenn der Einsatz von \Gls{BDT} sorgfältig und gut koordiniert umgesetzt wird, ist die damit einhergehende Versionierung der \Gls{COS} ein wertvoller Nebeneffekt, der die Organisation des Softwareprojekts vereinfacht.\\
Eine ähnliche Kombination von Methoden schlägt auch \citeauthor{binder_model-based_2014} vor \cite{binder_model-based_2014}. Er warnt aber davor, dass \Gls{BDT} nur einen kleinen Teil des \textit{happy-path} abdecken. Soll heißen, dass das System mittels \Gls{COS} nur auf sehr wenigen Pfaden getestet wird. Außerdem wächst die Anzahl der zu wartenden \Gls{BDD}-Spezifikationen mit der Größe der Code-Basis. Meist hat dies zur Folge, dass ältere Spezifikationen in Vergessenheit geraten und nicht mehr in die Regressionstests miteinbezogen werden. Um zweiterem Nachteil entgegenzuwirken müssen \Gls{BDD}-Spezifikationen sehr sorgfältig und mit Hinblick auf die Programmlogik entworfen werden. Außerdem muss die Versionierung Teamübergreifend nahtlos funktionieren.\\
Aus Kundensicht sind \Gls{COS} oft notwendig, da sie kurz und bündig vertragliche Abkommen darstellen. Auch wenn der Kunde beim Abnahmetest auf \Gls{COS} Spezifikationen besteht, muss das System durch breitere Maßnahmen regressiv getestet werden. Hier ergänzen modellbasierte Tests die Qualitätssicherungsmaßnahmen. Eine \Gls{COS} kann als einzelner Pfad in einem Modell gesehen werden. Der modellbasierte Test prüft dann, mit variablem Grad an Prüflogik, alle anderen Pfade. Diese Vorgehensweise schafft eine weitere Schicht an Sicherheit und lässt sich gut in bestehende Projekt- und Softwarestrukturen integrieren. Durch die Nutzung einer durchdachten Testing API (wie in Abschnitt \ref{sec:testing_api} beschrieben) können Wartungsaufwände minimiert werden, indem nur eine Codebasis für Adapter-Code besteht. Die Testing API stellt außerdem eine zukunftssichere Barriere vor Änderungen auf Seiten des Testwerkzeuges dar. Dieses kann ausgetauscht werden ohne die Aufwände für die Anbindung des \Gls{SUT} zunichte zu machen.\\
Die in Abschnitt \ref{sec:mbt_bdt_concept} vorgeschlagene kombinierte Verwendung von \Gls{BDT} und \Gls{MBT} lässt das Projekt von den Stärken beider Ansätze profitieren. \Gls{BDT} und \Gls{MBT} lassen sich sehr flexibel miteinander verschmelzen und sowohl den technischen als auch den organisatorisch geschäftlichen Prozessen anpassen. Das \Gls{SUT} kann damit systematischer und flächendeckender getestet werden ohne signifankte Mehraufwände in Kauf nehmen zu müssen.

%Gegen alle Anforderungen prüfen
